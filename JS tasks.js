// Задачи на программирование
// 1 задача склонение по падежу в зависимости от числа

function getCountComputers(n) {
    console.log("1. Задача. Сколенение по падежам, в зависимости от числа ");
    const lastDigit = n % 10;
    const lastTwoDigits = n % 100;
    if (lastTwoDigits >= 11 && lastTwoDigits <= 14) {
        return `${n} компьютеров`;
    }

    if (lastDigit === 1) {
        return `${n} компьютер`;
    }

    if (lastDigit >= 2 && lastDigit <= 4) {
        return `${n} компьютера`;
    }
    return `${n} компьютеров`;
}

console.log(getCountComputers(1));


// 2 задача общие делители

function getCommonDivisors(numbers) {
    console.log("2. Задача. Общие делители для чисел: " + numbers)
    let filterZero = numbers.filter(num => num !== 0);  /** выбираем значения отличные от нуля */
    /** сравниваем новый массив и начальный по длине, если длина изменилась, значит был 0 в начальном массиве */
    console.log("0 был исключен"); /** оповещение можем менять, для простоты сделал просто вывод в консоль лог */
    /** Дальше уже работаем с новым массивом без нуля. Если хотим что бы прекратилось действие,
     можем оставить по старому (мы просто заменили массив numbers на filterZero*/
    const commonDivisors = [];
    /** делаем пустой массив для хранения выходных значений */
    const minValue = Math.min(...filterZero);
    /** находим минимальное значение в массиве и перебираем все числа от 1 до этого числа */
    for (let i = 1; i <= minValue; i++) {
        /**
         every делает перебор массива на соответствие условия,
         в данном случае деления числа на перебор и сравнение к 0,
         после деления число должно быть без остатка
         */
        if (filterZero.every(num => num % i === 0)) {
            /**
             пушим число в ранее созданный пустой массив, при каждом переборе будет добавляться число,
             удовлетворяющее условия, пока не дойдет до минимального значения в перебираемом массиве,
             далее уже нет смысла искать, так как последним возможным делителем является минимальное
             число из этого массива
             */
            commonDivisors.push(i);
        }
    }
    return commonDivisors;
}

console.log(getCommonDivisors([3, 6, 12, 0]));

// 3 задача возврат простых числе, простые числа имеют два делителя, 1 и само на себя

function getPrimeNumbers(min, max) { /** функция принимающая на себя два числа */
    if (min > max) {
        [min, max] = [max, min]; /** При вводе значений от макс к мин - разворачивает данные на входе */
    }
    let inputNumbers = "3. Задача. Простые числа в интервале " + min.toString() + " и " + max.toString();
    console.log(inputNumbers);
    let primeNumbers = []; /** создаем пустой массив для дальнейшей записи туда выходных чисел */
    for (let i = min; i <= max; i++) { /** делаем перебор массива от минимального до максимального числа */
        if (isPrime(i)) {
            /** условие, если простое, то пушим в массив */
            primeNumbers.push(i);
        }
    }
    return primeNumbers;
}

function isPrime(n) { // проверка числа простое или нет
    /** проверяем число на 1 и меньше, то сразу false,
     у 1 один делитель на себя, на 0 делить нельзя */
    if (n < 2) return false;
    /** далее проверка на 3 и меньше, 2 и 3 являются простыми, числа меньше мы уже выше отсекли */
    if (n <= 3) return true;
    /** проверяем числа на четность и деление 3, эти числа изначально
     не могут быть простыми (кроме 2 и 3, которые мы обработали выше) */
    if (n % 2 == 0 || n % 3 == 0) return false;
    /** действия при i = 5, так проще проверять делители, четные и кратные 3 мы уже отсекли выше */
    let i = 5;
    /** условие работы цикла, i возводим в квадрат.
     Например, n = 19 (простое число). 5*5 <= 19 (25 <= 19) условие не выполнено */
    while (i * i <= n) {
        /** проверяем по двум условиям деления без остатка, если условие выполнено,
         то число не будет простым, соответственно возвращаем false */
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
        /** именно 6, потому что все что меньше мы уже проверили.
         Цикл проверить делимость уже при i = 11 и опять получит результат дробное число и вернет true,
         потому что не был найдет дополнительный делитель*/
        i += 6;
    }
    return true;
}

console.log(getPrimeNumbers(50, 1));

// 4 задача таблица умножения

function multiplicationTable(n) {
    console.log("4. Задача. Таблица умножения для числа " + n)
    /** Верхняя строка (заголовок таблицы). Отступ для первой пустой ячейки */
    let header = '    ';
    for (let i = 1; i <= n; i++) {
        /** делаем отступ, что бы не слиплись значения, за отступ отвечает padStart */
        header += i.toString().padStart(4, ' ');
    }
    console.log(header); /** выводим шапку таблицы от 1 до n */
    /** Горизонтальная линия с повторением на каждый n по 4 раза просто подгонял по консоли))) */
    console.log('   ' + '_'.repeat(n * 4));

    /** Таблица умножения */
    for (let i = 1; i <= n; i++) {
        /** Первая колонка с числом строки и разделитель. Просто число n из перебора + отступ */
        let row = i.toString().padStart(3, ' ') + '|';
        /** делаем перебор для второго множителя */
        for (let j = 1; j <= n; j++) {
            row += (i * j).toString().padStart(4, ' '); //
        }
        console.log(row); /** Вывод строки */
    }
}

console.log(multiplicationTable(15));
